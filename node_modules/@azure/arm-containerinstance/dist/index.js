'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreClient = require('@azure/core-client');
var tslib = require('tslib');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ContainerNetworkProtocol} that the service accepts. */
exports.KnownContainerNetworkProtocol = void 0;
(function (KnownContainerNetworkProtocol) {
    KnownContainerNetworkProtocol["TCP"] = "TCP";
    KnownContainerNetworkProtocol["UDP"] = "UDP";
})(exports.KnownContainerNetworkProtocol || (exports.KnownContainerNetworkProtocol = {}));
/** Known values of {@link GpuSku} that the service accepts. */
exports.KnownGpuSku = void 0;
(function (KnownGpuSku) {
    KnownGpuSku["K80"] = "K80";
    KnownGpuSku["P100"] = "P100";
    KnownGpuSku["V100"] = "V100";
})(exports.KnownGpuSku || (exports.KnownGpuSku = {}));
/** Known values of {@link Scheme} that the service accepts. */
exports.KnownScheme = void 0;
(function (KnownScheme) {
    KnownScheme["Http"] = "http";
    KnownScheme["Https"] = "https";
})(exports.KnownScheme || (exports.KnownScheme = {}));
/** Known values of {@link ContainerGroupRestartPolicy} that the service accepts. */
exports.KnownContainerGroupRestartPolicy = void 0;
(function (KnownContainerGroupRestartPolicy) {
    KnownContainerGroupRestartPolicy["Always"] = "Always";
    KnownContainerGroupRestartPolicy["OnFailure"] = "OnFailure";
    KnownContainerGroupRestartPolicy["Never"] = "Never";
})(exports.KnownContainerGroupRestartPolicy || (exports.KnownContainerGroupRestartPolicy = {}));
/** Known values of {@link ContainerGroupNetworkProtocol} that the service accepts. */
exports.KnownContainerGroupNetworkProtocol = void 0;
(function (KnownContainerGroupNetworkProtocol) {
    KnownContainerGroupNetworkProtocol["TCP"] = "TCP";
    KnownContainerGroupNetworkProtocol["UDP"] = "UDP";
})(exports.KnownContainerGroupNetworkProtocol || (exports.KnownContainerGroupNetworkProtocol = {}));
/** Known values of {@link ContainerGroupIpAddressType} that the service accepts. */
exports.KnownContainerGroupIpAddressType = void 0;
(function (KnownContainerGroupIpAddressType) {
    KnownContainerGroupIpAddressType["Public"] = "Public";
    KnownContainerGroupIpAddressType["Private"] = "Private";
})(exports.KnownContainerGroupIpAddressType || (exports.KnownContainerGroupIpAddressType = {}));
/** Known values of {@link AutoGeneratedDomainNameLabelScope} that the service accepts. */
exports.KnownAutoGeneratedDomainNameLabelScope = void 0;
(function (KnownAutoGeneratedDomainNameLabelScope) {
    KnownAutoGeneratedDomainNameLabelScope["Unsecure"] = "Unsecure";
    KnownAutoGeneratedDomainNameLabelScope["TenantReuse"] = "TenantReuse";
    KnownAutoGeneratedDomainNameLabelScope["SubscriptionReuse"] = "SubscriptionReuse";
    KnownAutoGeneratedDomainNameLabelScope["ResourceGroupReuse"] = "ResourceGroupReuse";
    KnownAutoGeneratedDomainNameLabelScope["Noreuse"] = "Noreuse";
})(exports.KnownAutoGeneratedDomainNameLabelScope || (exports.KnownAutoGeneratedDomainNameLabelScope = {}));
/** Known values of {@link OperatingSystemTypes} that the service accepts. */
exports.KnownOperatingSystemTypes = void 0;
(function (KnownOperatingSystemTypes) {
    KnownOperatingSystemTypes["Windows"] = "Windows";
    KnownOperatingSystemTypes["Linux"] = "Linux";
})(exports.KnownOperatingSystemTypes || (exports.KnownOperatingSystemTypes = {}));
/** Known values of {@link LogAnalyticsLogType} that the service accepts. */
exports.KnownLogAnalyticsLogType = void 0;
(function (KnownLogAnalyticsLogType) {
    KnownLogAnalyticsLogType["ContainerInsights"] = "ContainerInsights";
    KnownLogAnalyticsLogType["ContainerInstanceLogs"] = "ContainerInstanceLogs";
})(exports.KnownLogAnalyticsLogType || (exports.KnownLogAnalyticsLogType = {}));
/** Known values of {@link ContainerGroupSku} that the service accepts. */
exports.KnownContainerGroupSku = void 0;
(function (KnownContainerGroupSku) {
    KnownContainerGroupSku["Standard"] = "Standard";
    KnownContainerGroupSku["Dedicated"] = "Dedicated";
})(exports.KnownContainerGroupSku || (exports.KnownContainerGroupSku = {}));
/** Known values of {@link ContainerInstanceOperationsOrigin} that the service accepts. */
exports.KnownContainerInstanceOperationsOrigin = void 0;
(function (KnownContainerInstanceOperationsOrigin) {
    KnownContainerInstanceOperationsOrigin["User"] = "User";
    KnownContainerInstanceOperationsOrigin["System"] = "System";
})(exports.KnownContainerInstanceOperationsOrigin || (exports.KnownContainerInstanceOperationsOrigin = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const ContainerGroupListResult = {
    type: {
        name: "Composite",
        className: "ContainerGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerGroupIdentity = {
    type: {
        name: "Composite",
        className: "ContainerGroupIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "SystemAssigned",
                        "UserAssigned",
                        "SystemAssigned, UserAssigned",
                        "None"
                    ]
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "Components10Wh5UdSchemasContainergroupidentityPropertiesUserassignedidentitiesAdditionalproperties"
                        }
                    }
                }
            }
        }
    }
};
const Components10Wh5UdSchemasContainergroupidentityPropertiesUserassignedidentitiesAdditionalproperties = {
    type: {
        name: "Composite",
        className: "Components10Wh5UdSchemasContainergroupidentityPropertiesUserassignedidentitiesAdditionalproperties",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Container = {
    type: {
        name: "Composite",
        className: "Container",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            image: {
                serializedName: "properties.image",
                required: true,
                type: {
                    name: "String"
                }
            },
            command: {
                serializedName: "properties.command",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            ports: {
                serializedName: "properties.ports",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerPort"
                        }
                    }
                }
            },
            environmentVariables: {
                serializedName: "properties.environmentVariables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EnvironmentVariable"
                        }
                    }
                }
            },
            instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "ContainerPropertiesInstanceView"
                }
            },
            resources: {
                serializedName: "properties.resources",
                type: {
                    name: "Composite",
                    className: "ResourceRequirements"
                }
            },
            volumeMounts: {
                serializedName: "properties.volumeMounts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VolumeMount"
                        }
                    }
                }
            },
            livenessProbe: {
                serializedName: "properties.livenessProbe",
                type: {
                    name: "Composite",
                    className: "ContainerProbe"
                }
            },
            readinessProbe: {
                serializedName: "properties.readinessProbe",
                type: {
                    name: "Composite",
                    className: "ContainerProbe"
                }
            }
        }
    }
};
const ContainerPort = {
    type: {
        name: "Composite",
        className: "ContainerPort",
        modelProperties: {
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            port: {
                serializedName: "port",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const EnvironmentVariable = {
    type: {
        name: "Composite",
        className: "EnvironmentVariable",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            secureValue: {
                serializedName: "secureValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerPropertiesInstanceView = {
    type: {
        name: "Composite",
        className: "ContainerPropertiesInstanceView",
        modelProperties: {
            restartCount: {
                serializedName: "restartCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            currentState: {
                serializedName: "currentState",
                type: {
                    name: "Composite",
                    className: "ContainerState"
                }
            },
            previousState: {
                serializedName: "previousState",
                type: {
                    name: "Composite",
                    className: "ContainerState"
                }
            },
            events: {
                serializedName: "events",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Event"
                        }
                    }
                }
            }
        }
    }
};
const ContainerState = {
    type: {
        name: "Composite",
        className: "ContainerState",
        modelProperties: {
            state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            exitCode: {
                serializedName: "exitCode",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            finishTime: {
                serializedName: "finishTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            detailStatus: {
                serializedName: "detailStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Event = {
    type: {
        name: "Composite",
        className: "Event",
        modelProperties: {
            count: {
                serializedName: "count",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            firstTimestamp: {
                serializedName: "firstTimestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastTimestamp: {
                serializedName: "lastTimestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceRequirements = {
    type: {
        name: "Composite",
        className: "ResourceRequirements",
        modelProperties: {
            requests: {
                serializedName: "requests",
                type: {
                    name: "Composite",
                    className: "ResourceRequests"
                }
            },
            limits: {
                serializedName: "limits",
                type: {
                    name: "Composite",
                    className: "ResourceLimits"
                }
            }
        }
    }
};
const ResourceRequests = {
    type: {
        name: "Composite",
        className: "ResourceRequests",
        modelProperties: {
            memoryInGB: {
                serializedName: "memoryInGB",
                required: true,
                type: {
                    name: "Number"
                }
            },
            cpu: {
                serializedName: "cpu",
                required: true,
                type: {
                    name: "Number"
                }
            },
            gpu: {
                serializedName: "gpu",
                type: {
                    name: "Composite",
                    className: "GpuResource"
                }
            }
        }
    }
};
const GpuResource = {
    type: {
        name: "Composite",
        className: "GpuResource",
        modelProperties: {
            count: {
                serializedName: "count",
                required: true,
                type: {
                    name: "Number"
                }
            },
            sku: {
                serializedName: "sku",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceLimits = {
    type: {
        name: "Composite",
        className: "ResourceLimits",
        modelProperties: {
            memoryInGB: {
                serializedName: "memoryInGB",
                type: {
                    name: "Number"
                }
            },
            cpu: {
                serializedName: "cpu",
                type: {
                    name: "Number"
                }
            },
            gpu: {
                serializedName: "gpu",
                type: {
                    name: "Composite",
                    className: "GpuResource"
                }
            }
        }
    }
};
const VolumeMount = {
    type: {
        name: "Composite",
        className: "VolumeMount",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            mountPath: {
                serializedName: "mountPath",
                required: true,
                type: {
                    name: "String"
                }
            },
            readOnly: {
                serializedName: "readOnly",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ContainerProbe = {
    type: {
        name: "Composite",
        className: "ContainerProbe",
        modelProperties: {
            exec: {
                serializedName: "exec",
                type: {
                    name: "Composite",
                    className: "ContainerExec"
                }
            },
            httpGet: {
                serializedName: "httpGet",
                type: {
                    name: "Composite",
                    className: "ContainerHttpGet"
                }
            },
            initialDelaySeconds: {
                serializedName: "initialDelaySeconds",
                type: {
                    name: "Number"
                }
            },
            periodSeconds: {
                serializedName: "periodSeconds",
                type: {
                    name: "Number"
                }
            },
            failureThreshold: {
                serializedName: "failureThreshold",
                type: {
                    name: "Number"
                }
            },
            successThreshold: {
                serializedName: "successThreshold",
                type: {
                    name: "Number"
                }
            },
            timeoutSeconds: {
                serializedName: "timeoutSeconds",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ContainerExec = {
    type: {
        name: "Composite",
        className: "ContainerExec",
        modelProperties: {
            command: {
                serializedName: "command",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ContainerHttpGet = {
    type: {
        name: "Composite",
        className: "ContainerHttpGet",
        modelProperties: {
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            },
            port: {
                serializedName: "port",
                required: true,
                type: {
                    name: "Number"
                }
            },
            scheme: {
                serializedName: "scheme",
                type: {
                    name: "String"
                }
            },
            httpHeaders: {
                serializedName: "httpHeaders",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HttpHeader"
                        }
                    }
                }
            }
        }
    }
};
const HttpHeader = {
    type: {
        name: "Composite",
        className: "HttpHeader",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImageRegistryCredential = {
    type: {
        name: "Composite",
        className: "ImageRegistryCredential",
        modelProperties: {
            server: {
                serializedName: "server",
                required: true,
                type: {
                    name: "String"
                }
            },
            username: {
                serializedName: "username",
                required: true,
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "String"
                }
            },
            identityUrl: {
                serializedName: "identityUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IpAddress = {
    type: {
        name: "Composite",
        className: "IpAddress",
        modelProperties: {
            ports: {
                serializedName: "ports",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Port"
                        }
                    }
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            ip: {
                serializedName: "ip",
                type: {
                    name: "String"
                }
            },
            dnsNameLabel: {
                serializedName: "dnsNameLabel",
                type: {
                    name: "String"
                }
            },
            dnsNameLabelReusePolicy: {
                serializedName: "dnsNameLabelReusePolicy",
                type: {
                    name: "String"
                }
            },
            fqdn: {
                serializedName: "fqdn",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Port = {
    type: {
        name: "Composite",
        className: "Port",
        modelProperties: {
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            port: {
                serializedName: "port",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Volume = {
    type: {
        name: "Composite",
        className: "Volume",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            azureFile: {
                serializedName: "azureFile",
                type: {
                    name: "Composite",
                    className: "AzureFileVolume"
                }
            },
            emptyDir: {
                serializedName: "emptyDir",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            secret: {
                serializedName: "secret",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            gitRepo: {
                serializedName: "gitRepo",
                type: {
                    name: "Composite",
                    className: "GitRepoVolume"
                }
            }
        }
    }
};
const AzureFileVolume = {
    type: {
        name: "Composite",
        className: "AzureFileVolume",
        modelProperties: {
            shareName: {
                serializedName: "shareName",
                required: true,
                type: {
                    name: "String"
                }
            },
            readOnly: {
                serializedName: "readOnly",
                type: {
                    name: "Boolean"
                }
            },
            storageAccountName: {
                serializedName: "storageAccountName",
                required: true,
                type: {
                    name: "String"
                }
            },
            storageAccountKey: {
                serializedName: "storageAccountKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GitRepoVolume = {
    type: {
        name: "Composite",
        className: "GitRepoVolume",
        modelProperties: {
            directory: {
                serializedName: "directory",
                type: {
                    name: "String"
                }
            },
            repository: {
                serializedName: "repository",
                required: true,
                type: {
                    name: "String"
                }
            },
            revision: {
                serializedName: "revision",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerGroupPropertiesInstanceView = {
    type: {
        name: "Composite",
        className: "ContainerGroupPropertiesInstanceView",
        modelProperties: {
            events: {
                serializedName: "events",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Event"
                        }
                    }
                }
            },
            state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerGroupDiagnostics = {
    type: {
        name: "Composite",
        className: "ContainerGroupDiagnostics",
        modelProperties: {
            logAnalytics: {
                serializedName: "logAnalytics",
                type: {
                    name: "Composite",
                    className: "LogAnalytics"
                }
            }
        }
    }
};
const LogAnalytics = {
    type: {
        name: "Composite",
        className: "LogAnalytics",
        modelProperties: {
            workspaceId: {
                serializedName: "workspaceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            workspaceKey: {
                serializedName: "workspaceKey",
                required: true,
                type: {
                    name: "String"
                }
            },
            logType: {
                serializedName: "logType",
                type: {
                    name: "String"
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            workspaceResourceId: {
                serializedName: "workspaceResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerGroupSubnetId = {
    type: {
        name: "Composite",
        className: "ContainerGroupSubnetId",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DnsConfiguration = {
    type: {
        name: "Composite",
        className: "DnsConfiguration",
        modelProperties: {
            nameServers: {
                serializedName: "nameServers",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            searchDomains: {
                serializedName: "searchDomains",
                type: {
                    name: "String"
                }
            },
            options: {
                serializedName: "options",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EncryptionProperties = {
    type: {
        name: "Composite",
        className: "EncryptionProperties",
        modelProperties: {
            vaultBaseUrl: {
                serializedName: "vaultBaseUrl",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyName: {
                serializedName: "keyName",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyVersion: {
                serializedName: "keyVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InitContainerDefinition = {
    type: {
        name: "Composite",
        className: "InitContainerDefinition",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            image: {
                serializedName: "properties.image",
                type: {
                    name: "String"
                }
            },
            command: {
                serializedName: "properties.command",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            environmentVariables: {
                serializedName: "properties.environmentVariables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EnvironmentVariable"
                        }
                    }
                }
            },
            instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "InitContainerPropertiesDefinitionInstanceView"
                }
            },
            volumeMounts: {
                serializedName: "properties.volumeMounts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VolumeMount"
                        }
                    }
                }
            }
        }
    }
};
const InitContainerPropertiesDefinitionInstanceView = {
    type: {
        name: "Composite",
        className: "InitContainerPropertiesDefinitionInstanceView",
        modelProperties: {
            restartCount: {
                serializedName: "restartCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            currentState: {
                serializedName: "currentState",
                type: {
                    name: "Composite",
                    className: "ContainerState"
                }
            },
            previousState: {
                serializedName: "previousState",
                type: {
                    name: "Composite",
                    className: "ContainerState"
                }
            },
            events: {
                serializedName: "events",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Event"
                        }
                    }
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CloudErrorBody"
                }
            }
        }
    }
};
const CloudErrorBody = {
    type: {
        name: "Composite",
        className: "CloudErrorBody",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudErrorBody"
                        }
                    }
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UsageListResult = {
    type: {
        name: "Composite",
        className: "UsageListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Usage"
                        }
                    }
                }
            }
        }
    }
};
const Usage = {
    type: {
        name: "Composite",
        className: "Usage",
        modelProperties: {
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            currentValue: {
                serializedName: "currentValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "UsageName"
                }
            }
        }
    }
};
const UsageName = {
    type: {
        name: "Composite",
        className: "UsageName",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Logs = {
    type: {
        name: "Composite",
        className: "Logs",
        modelProperties: {
            content: {
                serializedName: "content",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerExecRequest = {
    type: {
        name: "Composite",
        className: "ContainerExecRequest",
        modelProperties: {
            command: {
                serializedName: "command",
                type: {
                    name: "String"
                }
            },
            terminalSize: {
                serializedName: "terminalSize",
                type: {
                    name: "Composite",
                    className: "ContainerExecRequestTerminalSize"
                }
            }
        }
    }
};
const ContainerExecRequestTerminalSize = {
    type: {
        name: "Composite",
        className: "ContainerExecRequestTerminalSize",
        modelProperties: {
            rows: {
                serializedName: "rows",
                type: {
                    name: "Number"
                }
            },
            cols: {
                serializedName: "cols",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ContainerExecResponse = {
    type: {
        name: "Composite",
        className: "ContainerExecResponse",
        modelProperties: {
            webSocketUri: {
                serializedName: "webSocketUri",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerAttachResponse = {
    type: {
        name: "Composite",
        className: "ContainerAttachResponse",
        modelProperties: {
            webSocketUri: {
                serializedName: "webSocketUri",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CachedImagesListResult = {
    type: {
        name: "Composite",
        className: "CachedImagesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CachedImages"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CachedImages = {
    type: {
        name: "Composite",
        className: "CachedImages",
        modelProperties: {
            osType: {
                serializedName: "osType",
                required: true,
                type: {
                    name: "String"
                }
            },
            image: {
                serializedName: "image",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CapabilitiesListResult = {
    type: {
        name: "Composite",
        className: "CapabilitiesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Capabilities"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Capabilities = {
    type: {
        name: "Composite",
        className: "Capabilities",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            osType: {
                serializedName: "osType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ipAddressType: {
                serializedName: "ipAddressType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            gpu: {
                serializedName: "gpu",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            capabilities: {
                serializedName: "capabilities",
                type: {
                    name: "Composite",
                    className: "CapabilitiesCapabilities"
                }
            }
        }
    }
};
const CapabilitiesCapabilities = {
    type: {
        name: "Composite",
        className: "CapabilitiesCapabilities",
        modelProperties: {
            maxMemoryInGB: {
                serializedName: "maxMemoryInGB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maxCpu: {
                serializedName: "maxCpu",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maxGpuCount: {
                serializedName: "maxGpuCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ContainerGroup = {
    type: {
        name: "Composite",
        className: "ContainerGroup",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ContainerGroupIdentity"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, containers: {
                serializedName: "properties.containers",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Container"
                        }
                    }
                }
            }, imageRegistryCredentials: {
                serializedName: "properties.imageRegistryCredentials",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ImageRegistryCredential"
                        }
                    }
                }
            }, restartPolicy: {
                serializedName: "properties.restartPolicy",
                type: {
                    name: "String"
                }
            }, ipAddress: {
                serializedName: "properties.ipAddress",
                type: {
                    name: "Composite",
                    className: "IpAddress"
                }
            }, osType: {
                serializedName: "properties.osType",
                required: true,
                type: {
                    name: "String"
                }
            }, volumes: {
                serializedName: "properties.volumes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Volume"
                        }
                    }
                }
            }, instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "ContainerGroupPropertiesInstanceView"
                }
            }, diagnostics: {
                serializedName: "properties.diagnostics",
                type: {
                    name: "Composite",
                    className: "ContainerGroupDiagnostics"
                }
            }, subnetIds: {
                serializedName: "properties.subnetIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerGroupSubnetId"
                        }
                    }
                }
            }, dnsConfig: {
                serializedName: "properties.dnsConfig",
                type: {
                    name: "Composite",
                    className: "DnsConfiguration"
                }
            }, sku: {
                serializedName: "properties.sku",
                type: {
                    name: "String"
                }
            }, encryptionProperties: {
                serializedName: "properties.encryptionProperties",
                type: {
                    name: "Composite",
                    className: "EncryptionProperties"
                }
            }, initContainers: {
                serializedName: "properties.initContainers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InitContainerDefinition"
                        }
                    }
                }
            } })
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ContainerGroupListResult: ContainerGroupListResult,
    ContainerGroupIdentity: ContainerGroupIdentity,
    Components10Wh5UdSchemasContainergroupidentityPropertiesUserassignedidentitiesAdditionalproperties: Components10Wh5UdSchemasContainergroupidentityPropertiesUserassignedidentitiesAdditionalproperties,
    Container: Container,
    ContainerPort: ContainerPort,
    EnvironmentVariable: EnvironmentVariable,
    ContainerPropertiesInstanceView: ContainerPropertiesInstanceView,
    ContainerState: ContainerState,
    Event: Event,
    ResourceRequirements: ResourceRequirements,
    ResourceRequests: ResourceRequests,
    GpuResource: GpuResource,
    ResourceLimits: ResourceLimits,
    VolumeMount: VolumeMount,
    ContainerProbe: ContainerProbe,
    ContainerExec: ContainerExec,
    ContainerHttpGet: ContainerHttpGet,
    HttpHeader: HttpHeader,
    ImageRegistryCredential: ImageRegistryCredential,
    IpAddress: IpAddress,
    Port: Port,
    Volume: Volume,
    AzureFileVolume: AzureFileVolume,
    GitRepoVolume: GitRepoVolume,
    ContainerGroupPropertiesInstanceView: ContainerGroupPropertiesInstanceView,
    ContainerGroupDiagnostics: ContainerGroupDiagnostics,
    LogAnalytics: LogAnalytics,
    ContainerGroupSubnetId: ContainerGroupSubnetId,
    DnsConfiguration: DnsConfiguration,
    EncryptionProperties: EncryptionProperties,
    InitContainerDefinition: InitContainerDefinition,
    InitContainerPropertiesDefinitionInstanceView: InitContainerPropertiesDefinitionInstanceView,
    Resource: Resource,
    CloudError: CloudError,
    CloudErrorBody: CloudErrorBody,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    UsageListResult: UsageListResult,
    Usage: Usage,
    UsageName: UsageName,
    Logs: Logs,
    ContainerExecRequest: ContainerExecRequest,
    ContainerExecRequestTerminalSize: ContainerExecRequestTerminalSize,
    ContainerExecResponse: ContainerExecResponse,
    ContainerAttachResponse: ContainerAttachResponse,
    CachedImagesListResult: CachedImagesListResult,
    CachedImages: CachedImages,
    CapabilitiesListResult: CapabilitiesListResult,
    Capabilities: Capabilities,
    CapabilitiesCapabilities: CapabilitiesCapabilities,
    ContainerGroup: ContainerGroup
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-10-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const containerGroupName = {
    parameterPath: "containerGroupName",
    mapper: {
        serializedName: "containerGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const containerGroup = {
    parameterPath: "containerGroup",
    mapper: ContainerGroup
};
const resource = {
    parameterPath: "resource",
    mapper: Resource
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const containerName = {
    parameterPath: "containerName",
    mapper: {
        serializedName: "containerName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const tail = {
    parameterPath: ["options", "tail"],
    mapper: {
        serializedName: "tail",
        type: {
            name: "Number"
        }
    }
};
const timestamps = {
    parameterPath: ["options", "timestamps"],
    mapper: {
        serializedName: "timestamps",
        type: {
            name: "Boolean"
        }
    }
};
const containerExecRequest = {
    parameterPath: "containerExecRequest",
    mapper: ContainerExecRequest
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ContainerGroups operations. */
class ContainerGroupsImpl {
    /**
     * Initialize a new instance of the class ContainerGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get a list of container groups in the specified subscription. This operation returns properties of
     * each container group including containers, image registry credentials, restart policy, IP address
     * type, OS type, state, and volumes.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a list of container groups in a specified subscription and resource group. This operation
     * returns properties of each container group including containers, image registry credentials, restart
     * policy, IP address type, OS type, state, and volumes.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get a list of container groups in the specified subscription. This operation returns properties of
     * each container group including containers, image registry credentials, restart policy, IP address
     * type, OS type, state, and volumes.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * Get a list of container groups in a specified subscription and resource group. This operation
     * returns properties of each container group including containers, image registry credentials, restart
     * policy, IP address type, OS type, state, and volumes.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Gets the properties of the specified container group in the specified subscription and resource
     * group. The operation returns the properties of each container group including containers, image
     * registry credentials, restart policy, IP address type, OS type, state, and volumes.
     * @param resourceGroupName The name of the resource group.
     * @param containerGroupName The name of the container group.
     * @param options The options parameters.
     */
    get(resourceGroupName, containerGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerGroupName, options }, getOperationSpec);
    }
    /**
     * Create or update container groups with specified configurations.
     * @param resourceGroupName The name of the resource group.
     * @param containerGroupName The name of the container group.
     * @param containerGroup The properties of the container group to be created or updated.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, containerGroupName, containerGroup, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, containerGroupName, containerGroup, options }, createOrUpdateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update container groups with specified configurations.
     * @param resourceGroupName The name of the resource group.
     * @param containerGroupName The name of the container group.
     * @param containerGroup The properties of the container group to be created or updated.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, containerGroupName, containerGroup, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, containerGroupName, containerGroup, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates container group tags with specified values.
     * @param resourceGroupName The name of the resource group.
     * @param containerGroupName The name of the container group.
     * @param resource The container group resource with just the tags to be updated.
     * @param options The options parameters.
     */
    update(resourceGroupName, containerGroupName, resource, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerGroupName, resource, options }, updateOperationSpec);
    }
    /**
     * Delete the specified container group in the specified subscription and resource group. The operation
     * does not delete other resources provided by the user, such as volumes.
     * @param resourceGroupName The name of the resource group.
     * @param containerGroupName The name of the container group.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, containerGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, containerGroupName, options }, deleteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete the specified container group in the specified subscription and resource group. The operation
     * does not delete other resources provided by the user, such as volumes.
     * @param resourceGroupName The name of the resource group.
     * @param containerGroupName The name of the container group.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, containerGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, containerGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Restarts all containers in a container group in place. If container image has updates, new image
     * will be downloaded.
     * @param resourceGroupName The name of the resource group.
     * @param containerGroupName The name of the container group.
     * @param options The options parameters.
     */
    beginRestart(resourceGroupName, containerGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, containerGroupName, options }, restartOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Restarts all containers in a container group in place. If container image has updates, new image
     * will be downloaded.
     * @param resourceGroupName The name of the resource group.
     * @param containerGroupName The name of the container group.
     * @param options The options parameters.
     */
    beginRestartAndWait(resourceGroupName, containerGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestart(resourceGroupName, containerGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stops all containers in a container group. Compute resources will be deallocated and billing will
     * stop.
     * @param resourceGroupName The name of the resource group.
     * @param containerGroupName The name of the container group.
     * @param options The options parameters.
     */
    stop(resourceGroupName, containerGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerGroupName, options }, stopOperationSpec);
    }
    /**
     * Starts all containers in a container group. Compute resources will be allocated and billing will
     * start.
     * @param resourceGroupName The name of the resource group.
     * @param containerGroupName The name of the container group.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, containerGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, containerGroupName, options }, startOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Starts all containers in a container group. Compute resources will be allocated and billing will
     * start.
     * @param resourceGroupName The name of the resource group.
     * @param containerGroupName The name of the container group.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, containerGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, containerGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all the network dependencies for this container group to allow complete control of network
     * setting and configuration. For container groups, this will always be an empty list.
     * @param resourceGroupName The name of the resource group.
     * @param containerGroupName The name of the container group.
     * @param options The options parameters.
     */
    getOutboundNetworkDependenciesEndpoints(resourceGroupName, containerGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerGroupName, options }, getOutboundNetworkDependenciesEndpointsOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ContainerInstance/containerGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerInstance/containerGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerInstance/containerGroups/{containerGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerInstance/containerGroups/{containerGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ContainerGroup
        },
        201: {
            bodyMapper: ContainerGroup
        },
        202: {
            bodyMapper: ContainerGroup
        },
        204: {
            bodyMapper: ContainerGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: containerGroup,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerInstance/containerGroups/{containerGroupName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ContainerGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: resource,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerInstance/containerGroups/{containerGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: ContainerGroup
        },
        201: {
            bodyMapper: ContainerGroup
        },
        202: {
            bodyMapper: ContainerGroup
        },
        204: {
            bodyMapper: ContainerGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const restartOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerInstance/containerGroups/{containerGroupName}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerInstance/containerGroups/{containerGroupName}/stop",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerInstance/containerGroups/{containerGroupName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOutboundNetworkDependenciesEndpointsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerInstance/containerGroups/{containerGroupName}/outboundNetworkDependenciesEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Sequence", element: { type: { name: "String" } } }
            }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List the operations for Azure Container Instance service.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List the operations for Azure Container Instance service.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/providers/Microsoft.ContainerInstance/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Location operations. */
class LocationImpl {
    /**
     * Initialize a new instance of the class Location class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the usage for a subscription
     * @param location The identifier for the physical azure location.
     * @param options The options parameters.
     */
    listUsage(location, options) {
        const iter = this.listUsagePagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listUsagePagingPage(location, options);
            }
        };
    }
    listUsagePagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagePagingPage_1() {
            let result = yield tslib.__await(this._listUsage(location, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listUsagePagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listUsagePagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the list of cached images on specific OS type for a subscription in a region.
     * @param location The identifier for the physical azure location.
     * @param options The options parameters.
     */
    listCachedImages(location, options) {
        const iter = this.listCachedImagesPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listCachedImagesPagingPage(location, options);
            }
        };
    }
    listCachedImagesPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCachedImagesPagingPage_1() {
            let result = yield tslib.__await(this._listCachedImages(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listCachedImagesNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listCachedImagesPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCachedImagesPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listCachedImagesPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get the list of CPU/memory/GPU capabilities of a region.
     * @param location The identifier for the physical azure location.
     * @param options The options parameters.
     */
    listCapabilities(location, options) {
        const iter = this.listCapabilitiesPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listCapabilitiesPagingPage(location, options);
            }
        };
    }
    listCapabilitiesPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCapabilitiesPagingPage_1() {
            let result = yield tslib.__await(this._listCapabilities(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listCapabilitiesNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listCapabilitiesPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCapabilitiesPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listCapabilitiesPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Get the usage for a subscription
     * @param location The identifier for the physical azure location.
     * @param options The options parameters.
     */
    _listUsage(location, options) {
        return this.client.sendOperationRequest({ location, options }, listUsageOperationSpec);
    }
    /**
     * Get the list of cached images on specific OS type for a subscription in a region.
     * @param location The identifier for the physical azure location.
     * @param options The options parameters.
     */
    _listCachedImages(location, options) {
        return this.client.sendOperationRequest({ location, options }, listCachedImagesOperationSpec);
    }
    /**
     * Get the list of CPU/memory/GPU capabilities of a region.
     * @param location The identifier for the physical azure location.
     * @param options The options parameters.
     */
    _listCapabilities(location, options) {
        return this.client.sendOperationRequest({ location, options }, listCapabilitiesOperationSpec);
    }
    /**
     * ListCachedImagesNext
     * @param location The identifier for the physical azure location.
     * @param nextLink The nextLink from the previous successful call to the ListCachedImages method.
     * @param options The options parameters.
     */
    _listCachedImagesNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listCachedImagesNextOperationSpec);
    }
    /**
     * ListCapabilitiesNext
     * @param location The identifier for the physical azure location.
     * @param nextLink The nextLink from the previous successful call to the ListCapabilities method.
     * @param options The options parameters.
     */
    _listCapabilitiesNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listCapabilitiesNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listUsageOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ContainerInstance/locations/{location}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsageListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listCachedImagesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ContainerInstance/locations/{location}/cachedImages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CachedImagesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listCapabilitiesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ContainerInstance/locations/{location}/capabilities",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CapabilitiesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listCachedImagesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CachedImagesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listCapabilitiesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CapabilitiesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Containers operations. */
class ContainersImpl {
    /**
     * Initialize a new instance of the class Containers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the logs for a specified container instance in a specified resource group and container group.
     * @param resourceGroupName The name of the resource group.
     * @param containerGroupName The name of the container group.
     * @param containerName The name of the container instance.
     * @param options The options parameters.
     */
    listLogs(resourceGroupName, containerGroupName, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerGroupName, containerName, options }, listLogsOperationSpec);
    }
    /**
     * Executes a command for a specific container instance in a specified resource group and container
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param containerGroupName The name of the container group.
     * @param containerName The name of the container instance.
     * @param containerExecRequest The request for the exec command.
     * @param options The options parameters.
     */
    executeCommand(resourceGroupName, containerGroupName, containerName, containerExecRequest, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            containerGroupName,
            containerName,
            containerExecRequest,
            options
        }, executeCommandOperationSpec);
    }
    /**
     * Attach to the output stream of a specific container instance in a specified resource group and
     * container group.
     * @param resourceGroupName The name of the resource group.
     * @param containerGroupName The name of the container group.
     * @param containerName The name of the container instance.
     * @param options The options parameters.
     */
    attach(resourceGroupName, containerGroupName, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerGroupName, containerName, options }, attachOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listLogsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerInstance/containerGroups/{containerGroupName}/containers/{containerName}/logs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Logs
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        tail,
        timestamps
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerGroupName,
        containerName
    ],
    headerParameters: [accept],
    serializer
};
const executeCommandOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerInstance/containerGroups/{containerGroupName}/containers/{containerName}/exec",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ContainerExecResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: containerExecRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerGroupName,
        containerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const attachOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerInstance/containerGroups/{containerGroupName}/containers/{containerName}/attach",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ContainerAttachResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerGroupName,
        containerName
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class ContainerInstanceManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the ContainerInstanceManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId Subscription credentials which uniquely identify Microsoft Azure subscription.
     *                       The subscription ID forms part of the URI for every service call.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-containerinstance/8.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        if (!options.credentialScopes) {
            options.credentialScopes = ["https://management.azure.com/.default"];
        }
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2021-10-01";
        this.containerGroups = new ContainerGroupsImpl(this);
        this.operations = new OperationsImpl(this);
        this.location = new LocationImpl(this);
        this.containers = new ContainersImpl(this);
    }
}

exports.ContainerInstanceManagementClient = ContainerInstanceManagementClient;
//# sourceMappingURL=index.js.map
